import{_ as e,r as t,o as p,c,a as n,b as a,d as l,e as o}from"./app-jmEemqZF.js";const u={},i=o(`<h2 id="_1-在我们日常开发中-最常用的三种方法以及其区别" tabindex="-1"><a class="header-anchor" href="#_1-在我们日常开发中-最常用的三种方法以及其区别" aria-hidden="true">#</a> 1.在我们日常开发中，最常用的三种方法以及其区别</h2><p>在Java中，创建线程主要有三种方法：继承Thread类，实现Runnable接口，以及实现Callable接口。以下是它们的主要用法和区别：</p><ol><li>继承Thread类： 这是创建线程的最直接方式。通过继承Thread类，你可以重写run()方法来定义线程的主要任务。然后，你可以创建Thread的实例，并调用start()方法启动线程。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程的主要任务</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">MyThread</span> myThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，Java不支持多重继承，所以如果你的类已经继承了其他类，你就不能再通过这种方式创建线程。 2. 实现Runnable接口： 这是在Java 1.1中引入的另一种创建线程的方式。与继承Thread类不同，实现Runnable接口的类可以同时被多个线程共享。也就是说，同一个Runnable对象可以被多个Thread对象使用。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程的主要任务</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">Thread</span> thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Thread</span> thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现Runnable接口的优点在于，如果你的类已经继承了其他类，你仍然可以通过实现Runnable接口来创建线程。此外，实现Runnable接口还允许你更好地封装任务逻辑，因为run()方法内的代码不会被外部直接访问。 3. 实现Callable接口： Callable接口与Runnable接口类似，但它的返回值和异常处理机制更加灵活。Callable接口的call()方法可以返回值，并且可以抛出受检异常。当线程执行完后，需要使用Future对象来获取返回值。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// 线程的主要任务，可以返回值和抛出异常</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> future1 <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> future2 <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Callable接口的主要优点在于它可以处理复杂的返回值和异常情况。然而，由于需要使用Future对象来获取返回值，所以使用Callable接口的代码通常比使用Runnable接口的代码更难理解。</p><h3 id="_2-更多的创建线程方式和原理" tabindex="-1"><a class="header-anchor" href="#_2-更多的创建线程方式和原理" aria-hidden="true">#</a> 2. 更多的创建线程方式和原理</h3><p>Java创建线程有很多种方式啊，像实现Runnable、Callable接口、继承Thread类、创建线程池等等，不过这些方式并没有真正创建出线程，严格来说，Java就只有一种方式可以创建线程，那就是通过new Thread().start()创建。</p><p>而所谓的Runnable、Callable……对象，这仅仅只是线程体，也就是提供给线程执行的任务，并不属于真正的Java线程，它们的执行，最终还是需要依赖于new Thread()……</p><blockquote><p>线程体和线程的关系：线程是执行线程体的容器，线程体是一个可运行的任务</p></blockquote><p>Java中创建线程体的方式，可以基于Runnable创建，也可以靠Callable创建带返回的、也可以通过Timer创建支持定时的……，但不管是哪种方式，到最后都是依赖Runnable这个类实现的：Callable实际上就是Runnable的封装体。 到这里，搞清线程与线程体的关系后，就一定明为何说：Java中创建线程只有Thread.start()这一种方式的原因了！而<strong>最开始给出的其他方式，要么是在封装Thread.start()，要么是在创建线程体，而这个所谓的线程体，更接地气的说，应该是“多线程任务”。</strong></p>`,14),r={href:"https://juejin.cn/post/7241395267797942329#heading-13",target:"_blank",rel:"noopener noreferrer"};function k(d,v){const s=t("ExternalLinkIcon");return p(),c("div",null,[i,n("blockquote",null,[n("p",null,[a("参考相关优秀文章，稀土掘金"),n("a",r,[a("大家都说Java有三种创建线程的方式！并发编程中的惊天骗局！"),l(s)])])])])}const b=e(u,[["render",k],["__file","javazhongchuangjianxianchengdefangshi.html.vue"]]);export{b as default};
