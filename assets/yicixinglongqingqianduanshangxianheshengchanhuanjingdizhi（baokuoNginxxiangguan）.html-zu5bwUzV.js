import{_ as e,r as o,o as p,c as t,a as n,b as a,d as i,e as r}from"./app-jmEemqZF.js";const c="/reco-blog/assets/1-e3d0bf81.jpg",l="/reco-blog/assets/2-5e1d5f31.jpg",d="/reco-blog/assets/3-746278d4.jpg",u="/reco-blog/assets/4-ea6afc74.jpg",g="/reco-blog/assets/5-32e65d16.jpg",x="/reco-blog/assets/6-91ff8dff.jpg",k={},m=n("div",{class:"custom-container tip"},[n("svg",{xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",viewBox:"0 0 24 24"},[n("g",{fill:"none",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"},[n("circle",{cx:"12",cy:"12",r:"9"}),n("path",{d:"M12 8h.01"}),n("path",{d:"M11 12h1v4h1"})])]),n("p",{class:"custom-container-title"},"TIP"),n("p",null,"不知道小伙伴在前端开发的时候有没有这样的困惑")],-1),h=r('<ol><li>前端项目打包后，我打包过的静态资源是如何访问后端服务的？</li><li>访问后端服务的时候难道不存在跨域的问题吗？如何解决的？</li><li>假如我想自己简单修改下部署后的目录该如何去做？</li></ol><h2 id="_1-明确问题" tabindex="-1"><a class="header-anchor" href="#_1-明确问题" aria-hidden="true">#</a> 1. 明确问题</h2><p>我们知道，我们平时在开发的时候一般都是使用<strong>proxy</strong>进行代理的，它的原理是：浏览器会先去访问本地的node服务器，然后node服务器再去代理到你要访问的后端api接口，但是我们可能平时没有node服务器的概念，因为node服务器在webpack中，我们一般是通过下面这种方式来设置</p><p><img src="'+c+'" alt="图片"></p><p>但是我们的项目上线后这种方式就不能用了，（因为Node是我们本地开发的环境，并没有办法在线上使用。）其实，我们一般会通过后端的Nginx代理来解决跨域的问题，但是你知道前端的生产地址配置是什么吗？如何通过<strong>Nginx</strong>访问后端接口呢？是直接配置的类似于http://www.xxxx.com/api/aaa这样的路径呢？还是直接是一个相对路径/prod？要想搞清楚这些，首先就要了解什么是Nginx。</p><h2 id="_2-什么是nginx" tabindex="-1"><a class="header-anchor" href="#_2-什么是nginx" aria-hidden="true">#</a> 2. 什么是Nginx?</h2><p>是一个开源的高性能、轻量级的Web服务器和反向代理服务器，它具有事件驱动，异步非阻塞的架构，被广泛应用于构建高性能的网站，应用程序和服务。</p><p>在平时开发中我们经常听到正向代理和反向代理这两个名词，那么什么是反向代理，什么是正向代理哪？</p><ol><li>反向代理：服务器的IP是被屏蔽的，也就是说客户端不知道服务器真实的地址是哪个，客户端访问的地址或者域名是访问的Nginx服务器的地址。</li></ol><p><img src="'+l+'" alt="图片"></p><ol start="2"><li>正向代理：和反向代理刚好相反，这个时候服务器不知道真正的客户端是哪个，也就是相当于直接访问服务器的是nginx代理服务器。</li></ol><p><img src="'+d+'" alt="图片"></p><h2 id="_3-前端使用nginx解决跨域" tabindex="-1"><a class="header-anchor" href="#_3-前端使用nginx解决跨域" aria-hidden="true">#</a> 3. 前端使用Nginx解决跨域</h2><p>什么是跨域，跨域是指在浏览器的环境下，当一个网页的JavaScript代码通过Ajax Websocket或其他技术发送HTTP请求的目标资源位于不同的域名，端口或者协议下，就会发生跨域。</p><p>Nginx如何解决跨域，因为服务器和服务器之间互相请求不发生跨域，所以解决跨域的方法之一就是使用这种方案</p><ol><li>浏览器或者客户端发送请求：http:www.xxx.com:80 Nginx服务器对80端口进行监听，Nginx服务器将请求转发到后端真实的服务器地址，这样就实现了代理。</li></ol><p><img src="'+u+`" alt="图片"></p><ol start="2"><li>Nginx基本配置项解析</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>server <span class="token punctuation">{</span>
  listen <span class="token number">80</span><span class="token punctuation">;</span>
  server_name yourdomain<span class="token punctuation">.</span>com<span class="token punctuation">;</span>

  location <span class="token operator">/</span> <span class="token punctuation">{</span>     <span class="token comment">// 无论访问所有路径都返回前端静态资源dist内容</span>
    root <span class="token operator">/</span>path<span class="token operator">/</span>to<span class="token operator">/</span>your<span class="token operator">/</span>frontend<span class="token punctuation">;</span>
    index index<span class="token punctuation">.</span>html<span class="token punctuation">;</span>
    try_files $uri $uri<span class="token operator">/</span> <span class="token operator">/</span>index<span class="token punctuation">.</span>html<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  location <span class="token operator">/</span>api<span class="token operator">/</span> <span class="token punctuation">{</span>
    proxy_pass http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>backend<span class="token operator">-</span>server<span class="token operator">-</span>address<span class="token operator">/</span>api<span class="token operator">/</span><span class="token punctuation">;</span> <span class="token comment">// 真实后端api地址</span>
    proxy_set_header Host $host<span class="token punctuation">;</span>
    proxy_set_header <span class="token constant">X</span><span class="token operator">-</span>Real<span class="token operator">-</span><span class="token constant">IP</span> $remote_addr<span class="token punctuation">;</span>
    proxy_set_header <span class="token constant">X</span><span class="token operator">-</span>Forwarded<span class="token operator">-</span>For $proxy_add_x_forwarded_for<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当在前端代码中使用相对路径/api/users发起请求时候Nginx会将这个请求转发到真实的后端地址，不过你发现了没很多前端项目种生产环境地址都仅仅是一个/api类似这样的相对路径，很少直接是一个绝对路径。</p><p>当你请求 yourdomain.com 时，Nginx 会将前端静态资源返回给前端。前端代码中使用的相对路径 /api会基于当前域名 yourdomain.com构建完整的请求 URL。因此，前端代码请求后端地址的完整 URL 将是 yourdomain.com/api/xxx，其中 /xxx表示具体的后端接口路径。</p><p>Nginx 的反向代理配置中的 location /api/ 指令将匹配以 /api/ 开头的请求，并将这些请求代理到后端服务器上。因此，当前端代码发起相对路径请求 /api/xxx 时，Nginx 会将请求转发到 yourdomain.com/api/xxx，实现与后端接口的通信。</p><p>总结来说，前端代码中的相对路径 /api会根据当前域名构建完整的请求 URL，而 Nginx 的反向代理配置将这些请求转发到后端服务器上的相应路径。这样，前端代码就能够与后端接口进行通信。</p><h2 id="_4-前端生产环境配置" tabindex="-1"><a class="header-anchor" href="#_4-前端生产环境配置" aria-hidden="true">#</a> 4. 前端生产环境配置</h2><p>既然Nginx如何代理的，以及前端打包的路径一般是什么样的我们知道了，那么我们就来唠唠作为一个前端小白该如何快速的完整的构建一个基础项目吧，其实如果基础开发的话，我们往往会使用脚手架，就以Vue开发的话，我们可以使用vuecli来快速构建项目，其实构建完之后你就可以直接npm run build打出的包就可以部署在后端服务器的，这个打出的包的根路径是默认的/，通过上面的Nginx的知识我们应该不难理解。</p><p>如果我们要自己想去修改一个路径哪？我们可以在vue.config.js中进行配置，配置如下</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">publicPath</span><span class="token operator">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">===</span> <span class="token string">&#39;production&#39;</span> <span class="token operator">?</span> <span class="token string">&#39;/prod&#39;</span> <span class="token operator">:</span> <span class="token string">&#39;/&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样打出的包的静态资源的路径就是下边这样的</p><p><img src="`+g+'" alt="图片"></p><p>如果是直接使用的默认的打包路径就是如下这种</p><p><img src="'+x+'" alt="图片"></p><p>最后总结一下，前端上线打包完就是一个静态文件，是一个相对路径，后端会通过Nginx来监听这个资源的请求，当匹配到/就返回静态资源，当匹配到某个/prod就将请求反向代理到后端真实服务器的地址，前端打包的是一个相对路径，Nginx会在前面拼上去具体的域名或者ip，这样就打通了线上前端访问的基本内容。</p><h2 id="_5-一点点小小引申" tabindex="-1"><a class="header-anchor" href="#_5-一点点小小引申" aria-hidden="true">#</a> 5. 一点点小小引申</h2><p>Spring Boot配置CORS可以很方便地解决跨域问题，因为CORS是一种浏览器安全机制，允许不同域的前端网页向其他域的服务器发送请求。通过在Spring Boot中配置CORS响应头，可以轻松地允许来自不同域的请求访问。</p><p>而Nginx作为一个高性能的Web服务器和反向代理服务器，也可以用于解决跨域问题。Nginx可以通过配置代理来转发请求到后端服务器，并设置适当的响应头来解决跨域问题。但是，Nginx的配置相对复杂一些，需要更多的手动操作。</p><p>在生产环境中，通常会使用Nginx作为反向代理服务器来处理负载均衡、静态文件服务和HTTPS等其他问题。虽然Nginx也可以解决跨域问题，但配置CORS在Spring Boot中更为简单和直接。因此，在开发环境中，通常会使用Spring Boot配置CORS来解决跨域问题，而在生产环境中，可能会使用Nginx作为反向代理服务器，同时配置CORS来解决跨域问题。</p>',36),v={href:"https://juejin.cn/post/7291952951048060940",target:"_blank",rel:"noopener noreferrer"};function _(b,N){const s=o("ExternalLinkIcon");return p(),t("div",null,[m,h,n("blockquote",null,[n("p",null,[a("引用链接："),n("a",v,[a("稀土掘金"),i(s)])])])])}const F=e(k,[["render",_],["__file","yicixinglongqingqianduanshangxianheshengchanhuanjingdizhi（baokuoNginxxiangguan）.html.vue"]]);export{F as default};
